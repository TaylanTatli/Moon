---
layout: post
title: Fatebook
excerpt: "App for creating and sharing interactive stories"
date:   2016-07-26
project: true
heroku-link: https://bloc-jams-foundation-app.herokuapp.com/
github-link: https://github.com/transplanar/bloc-jams-angular
featured: true
tag:
- Bloc
- Frontend
- Backend
- Fullstack
- Angular
- Rails
- Capstone

comments: true
---

# The Project
*Fatebook is a social platform for creating and sharing interactive, choose-your-own-adventure stories. As an Angular on Rails application, it is the culmination of my Rails and Angular studies through Bloc.*

### Tools
[Javascript](https://www.javascript.com/), [Angular](https://angularjs.org/), [UI-Router](https://github.com/angular-ui/ui-router), [jQuery](https://jquery.com/), [Firebase](https://www.firebase.google.com/), [AngularFire](https://github.com/firebase/angularfire),
[Grunt](http://gruntjs.com/), [ngCookies](https://docs.angularjs.org/api/ngCookies), [Bootstrap](http://getbootstrap.com/), [Brackets](http://brackets.io/), [Ubuntu](http://www.ubuntu.com/)

# The App
*Upon entering the app, users are able to play through any existing published story. When playing through a story, they will see a paragraph or two of text, followed my a set of options. Each option will take the user down a new story thread. Users may select these chooses by clicking or pressing the corresponding number on their keyboard.*

*Should a user want to create their own story, they must log in and select "create story". From here they can provide a title and description of their story. Upon creating the story, the first page is automatically generated. After populating the content of the page, they can click "create option" to define a new option players can choose. They can then click the "Edit Page" button for that new option to go directly to a page generated for that option.*

*At any time, users can use the buttons along the top to navigate to the parent page, parent story, or view sibling stories on the same level of the story tree. Additionally, users may view the story tree at the bottom of the page, allowing them to easily traverse their story and identify which story threads remain unfinished.*

# The Process
*While planning the project, I defined two main states: Play mode, where a user is playing through someone's story, and Edit mode, where a user is creating or editing one of their own stories.*

*I began with the Play state, starting initially as a pure Angular application. I created a system where a ```Story``` object would contain an array of ```Pages```. Each ```Page``` would contain an array of ```choices```, which would be an object hash with the attributes of ```text``` for the text of the choice the users sees, and ```dest``` for the ID of the destination page.*

{% highlight Javascript %}
var Page = function(args){
   this.parentPage = args.parentPage;
   this.id = args.id;
   this.content = args.content;

   this.init = function(args){
     this.title = args.title;
     this.summary = args.summary;
     this.content = args.content;
     this.choices = args.choices; //Displayed to user

     return this;
   }

   this.createChildPages = function(){
     if(this.choices){
       for(var i = 0; i < this.choices.length; i++){
         var newPageID = getBranchID(this, i);
         createPlaceholderPage(this, newPageID);

         this.choices[i].dest = newPageID;
       }
     }
   }

   this.init(args);
 };
{% endhighlight %}

*To make nested seeding of page data easier, I used a page ID system I came up with for a short branching story I wrote years ago called Doors (which I ended up using as the example story for my app.) The naming convention consisted of alternating numbers and letters to indicate the number of levels down through the story a user had navigated. For example, the first page would have a ```id``` of "1", with child pages of "1A" and "1B". This could be chained indefinitely, so a page like "1A2B2" would be the child of page "1A2B" and sibling to "1A2B1".*

*This ```id``` was auto-generated using the following code (annotations added as comments):*
{% highlight Javascript %}
var getBranchID = function(parent, index){
  if(parent){
    var idString = parent.id.toString();
    var lastChar = idString[idString.length -1];

    //Uses a regular expression to test if last character
    // of parent pageID is a number or letter
    var reg = /^\d+$/;

    if(reg.test(lastChar)){
      return parent.id + indexToAlpha(index);
    }else{
      return parent.id + (index+1);
    }
  }
}
{% endhighlight %}

*Using this ```id``` system and the functions built into the ```Page``` object, I set up a system for easily populating a test array of pages. To do this, I first created a dummy first page, then used an ```editPage``` function I created to create an repeatable format I could use to populate all pages.*

{% highlight Javascript %}
StoryNavSrv.editPage = function(id, args){
  var page = getPageFromID(id);

  if(page){
    page
      .init(args)
      .createChildPages();
  }else{
    console.warn('Attempt to edit with invalid page id "' + id + '" SKIPPING');
  }
}

...

createPlaceholderPage(null, 1);
StoryNavSrv.currentPage = StoryNavSrv.currentStory.pages[0];

StoryNavSrv
  .editPage('1',
     {
        title: 'Initial page',
        summary: 'First page',
        content: 'You see two doors. Which do you choose?',
        choices: [
          {text: 'Left door'},
          {text: 'Right door'}
        ],
      });
StoryNavSrv
  .editPage('1A',
     {
      title: 'Left door',
      summary: 'First page',
      content: 'You entered the LEFT door.',
    });
StoryNavSrv
  .editPage('1B',
     {
      title: 'Left door',
      summary: 'First page',
      content: 'You entered the RIGHT door.',
      choices: [
        {text: 'Or did I?'},
        {text: 'No I didn\'t'},
      ],
    });
...
{% endhighlight %}

*With a working story navigation system working, I decided to add in keyboard controls as well.*

{% highlight Javascript %}
angular.element(document).bind('keyup', function (e) {
  if(StoryNavSrv.currentPage && StoryNavSrv.currentPage.choices){
    var choiceIndex = e.keyCode - 49;
    var page = StoryNavSrv.currentPage;
    var choice = page.choices[choiceIndex];

    if(choice){
      $scope.$apply($scope.setPage(choice.dest));
    }
  }
});
{% endhighlight %}

*With a working frontend implementation, I then moved on to add a Rails backend. Following a guide I found on youtube, I was able to get Angular to communicate with Rails, though it was a tricky process. I had to do some research to find the gems I required, namely ```angular-rails-templates``` to enable my Angular templates to be used in the Rails asset pipeline.*

*My Rails backend became an API to store and pass data to Angular via the UI-Router service. It accomplished this by passing returning JSON to my Frontend, after being processed by the appropriate ```ActiveRecordSerializer``` to ensure the relevant attributes were properly passed.*

 *It took me a little while to make sense of creating these accessor services, but eventually it clicked and made sense how the urls they used corresponded to the routes created by Rails.*

{% highlight Javascript %}
(function(){
  function PageSrv($resource) {
    return $resource('/pages/:id.json', {id: '@id'},
    {
      query: {method: 'GET', isArray: true},
      create: {method: 'POST'},
      show: {method: 'GET'},
      update: {method: 'PUT'},
      delete: {method: 'DELETE'},
      first: {method: 'GET', url: '/pages/get_first_page/:story_id'}
    });
  }

  angular
    .module('fatebook')
    .factory('PageSrv',['$resource', PageSrv])
})()

{% endhighlight %}

*I hit some friction coming up with the best approach for setting up the ```ActiveRecord``` associations between Stories, Pages, and child Pages. My initial thought was to create a ```has_many :through``` relationship, using a ```branch``` model to link a parent page to a destination page. This created an odd situation where each page ```has_many``` pages and ```belongs_to``` a parent page, which just wasn't working right.*

{% highlight ruby %}
class Page < ActiveRecord::Base
  belongs_to :story
  has_many :branches, :class_name => 'Page', foreign_key: :parent_id
  belongs_to :parent_page, :class_name => 'Page', foreign_key: :parent_id
end
{% endhighlight %}

*After some thought and consultation with my mentor, I realized there was a better approach. Rather than having pages be linked to each other directly, I could instead define a ```Branch``` join table to link pages together. The result was a much cleaner association.*

{% highlight ruby %}
class Page < ActiveRecord::Base
  belongs_to :story
  has_many :branches, foreign_key: :parent_id
end

class Branch < ActiveRecord::Base
  belongs_to :story
  belongs_to :parent_page, :class_name => 'Page', foreign_key: :parent_id
  belongs_to :destination_page, :class_name => 'Page', foreign_key: :destination_id, dependent: :destroy
end

{% endhighlight %}



{% highlight Javascript %}
{% endhighlight %}
